// @generated by protobuf-ts 2.9.0 with parameter long_type_string
// @generated from protobuf file "sp_external.proto" (package "protos", syntax proto3)
// tslint:disable
import { TailResponse } from "./sp_common.ts";
import { TailRequest } from "./sp_common.ts";
import { StandardResponse } from "./sp_common.ts";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Schema } from "./sp_common.ts";
import { AudienceRate } from "./sp_common.ts";
import { Metric } from "./sp_common.ts";
import { NotificationConfig } from "./sp_notify.ts";
import { Pipeline } from "./sp_pipeline.ts";
import { PipelineConfig } from "./sp_pipeline.ts";
import { PipelineInfo } from "./sp_info.ts";
import { Audience } from "./sp_common.ts";
import { LiveInfo } from "./sp_info.ts";
/**
 * Don't think there is anything to pass in (yet)?
 *
 * @generated from protobuf message protos.GetAllRequest
 */
export interface GetAllRequest {
}
/**
 * @generated from protobuf message protos.GetAllResponse
 */
export interface GetAllResponse {
    /**
     * Clients currently connected to the server
     *
     * @generated from protobuf field: repeated protos.LiveInfo live = 1;
     */
    live: LiveInfo[];
    /**
     * All of the audiences that are known to the server
     *
     * @generated from protobuf field: repeated protos.Audience audiences = 2;
     */
    audiences: Audience[];
    /**
     * All of the pipelines known to the server + pipeline <-> audience mappings
     * key == pipeline_id; if "Audience" is not filled out - pipeline is not attached
     * to any audience.
     *
     * @generated from protobuf field: map<string, protos.PipelineInfo> pipelines = 3;
     */
    pipelines: {
        [key: string]: PipelineInfo;
    };
    /**
     * Audience to pipeline ID config/mapping.
     * key == $audience_as_string, value = $pipeline_id
     *
     * @generated from protobuf field: map<string, protos.GetAllResponsePipelines> config = 4;
     */
    config: {
        [key: string]: GetAllResponsePipelines;
    };
    /**
     * When was this response generated. This is useful for determining what is
     * the latest update when using GetAllStream().
     *
     * @generated from protobuf field: int64 generated_at_unix_ts_ns_utc = 100;
     */
    generatedAtUnixTsNsUtc: string;
    /**
     * Set by server to indicate that the response is a keepalive message
     *
     * @generated from protobuf field: optional bool _keepalive = 1000;
     */
    Keepalive?: boolean; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}
/**
 * @generated from protobuf message protos.GetAllResponsePipelines
 */
export interface GetAllResponsePipelines {
    /**
     * @generated from protobuf field: repeated protos.PipelineConfig configs = 1;
     */
    configs: PipelineConfig[];
}
/**
 * Don't think we need anything here
 *
 * @generated from protobuf message protos.GetPipelinesRequest
 */
export interface GetPipelinesRequest {
}
/**
 * @generated from protobuf message protos.GetPipelinesResponse
 */
export interface GetPipelinesResponse {
    /**
     * @generated from protobuf field: repeated protos.Pipeline pipelines = 1;
     */
    pipelines: Pipeline[];
}
/**
 * @generated from protobuf message protos.GetPipelineRequest
 */
export interface GetPipelineRequest {
    /**
     * @generated from protobuf field: string pipeline_id = 1;
     */
    pipelineId: string;
}
/**
 * @generated from protobuf message protos.GetPipelineResponse
 */
export interface GetPipelineResponse {
    /**
     * @generated from protobuf field: protos.Pipeline pipeline = 1;
     */
    pipeline?: Pipeline;
}
/**
 * @generated from protobuf message protos.CreatePipelineRequest
 */
export interface CreatePipelineRequest {
    /**
     * @generated from protobuf field: protos.Pipeline pipeline = 1;
     */
    pipeline?: Pipeline;
}
/**
 * @generated from protobuf message protos.CreatePipelineResponse
 */
export interface CreatePipelineResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: string pipeline_id = 2;
     */
    pipelineId: string;
}
/**
 * @generated from protobuf message protos.UpdatePipelineRequest
 */
export interface UpdatePipelineRequest {
    /**
     * @generated from protobuf field: protos.Pipeline pipeline = 1;
     */
    pipeline?: Pipeline;
}
/**
 * @generated from protobuf message protos.DeletePipelineRequest
 */
export interface DeletePipelineRequest {
    /**
     * @generated from protobuf field: string pipeline_id = 1;
     */
    pipelineId: string;
}
/**
 * @generated from protobuf message protos.SetPipelinesRequest
 */
export interface SetPipelinesRequest {
    /**
     * @generated from protobuf field: repeated string pipeline_ids = 1;
     */
    pipelineIds: string[];
    /**
     * @generated from protobuf field: protos.Audience audience = 2;
     */
    audience?: Audience;
}
/**
 * @generated from protobuf message protos.PausePipelineRequest
 */
export interface PausePipelineRequest {
    /**
     * @generated from protobuf field: string pipeline_id = 1;
     */
    pipelineId: string;
    /**
     * @generated from protobuf field: protos.Audience audience = 2;
     */
    audience?: Audience;
}
/**
 * @generated from protobuf message protos.ResumePipelineRequest
 */
export interface ResumePipelineRequest {
    /**
     * @generated from protobuf field: string pipeline_id = 1;
     */
    pipelineId: string;
    /**
     * @generated from protobuf field: protos.Audience audience = 2;
     */
    audience?: Audience;
}
/**
 * Notifications
 *
 * @generated from protobuf message protos.CreateNotificationRequest
 */
export interface CreateNotificationRequest {
    /**
     * @generated from protobuf field: protos.NotificationConfig notification = 1;
     */
    notification?: NotificationConfig;
}
/**
 * @generated from protobuf message protos.UpdateNotificationRequest
 */
export interface UpdateNotificationRequest {
    /**
     * @generated from protobuf field: protos.NotificationConfig notification = 1;
     */
    notification?: NotificationConfig;
}
/**
 * @generated from protobuf message protos.DeleteNotificationRequest
 */
export interface DeleteNotificationRequest {
    /**
     * @generated from protobuf field: string notification_id = 1;
     */
    notificationId: string;
}
/**
 * Don't think we need anything here
 *
 * @generated from protobuf message protos.GetNotificationsRequest
 */
export interface GetNotificationsRequest {
}
/**
 * @generated from protobuf message protos.GetNotificationsResponse
 */
export interface GetNotificationsResponse {
    /**
     * Key == id of the notification config
     *
     * @generated from protobuf field: map<string, protos.NotificationConfig> notifications = 1;
     */
    notifications: {
        [key: string]: NotificationConfig;
    };
}
/**
 * @generated from protobuf message protos.GetNotificationRequest
 */
export interface GetNotificationRequest {
    /**
     * @generated from protobuf field: string notification_id = 1;
     */
    notificationId: string;
}
/**
 * @generated from protobuf message protos.GetNotificationResponse
 */
export interface GetNotificationResponse {
    /**
     * @generated from protobuf field: protos.NotificationConfig notification = 1;
     */
    notification?: NotificationConfig;
}
/**
 * @generated from protobuf message protos.AttachNotificationRequest
 */
export interface AttachNotificationRequest {
    /**
     * @generated from protobuf field: string notification_id = 1;
     */
    notificationId: string;
    /**
     * @generated from protobuf field: string pipeline_id = 2;
     */
    pipelineId: string;
}
/**
 * @generated from protobuf message protos.DetachNotificationRequest
 */
export interface DetachNotificationRequest {
    /**
     * @generated from protobuf field: string notification_id = 1;
     */
    notificationId: string;
    /**
     * @generated from protobuf field: string pipeline_id = 2;
     */
    pipelineId: string;
}
/**
 * @generated from protobuf message protos.DeleteAudienceRequest
 */
export interface DeleteAudienceRequest {
    /**
     * @generated from protobuf field: protos.Audience audience = 1;
     */
    audience?: Audience;
    /**
     * If true, will also detach all pipelines from the audience (if it has any)
     *
     * @generated from protobuf field: optional bool force = 2;
     */
    force?: boolean;
}
/**
 * @generated from protobuf message protos.DeleteServiceRequest
 */
export interface DeleteServiceRequest {
    /**
     * @generated from protobuf field: string service_name = 1;
     */
    serviceName: string;
    /**
     * @generated from protobuf field: optional bool force = 2;
     */
    force?: boolean;
}
/**
 * Nothing needed here, we return all metrics currently
 *
 * @generated from protobuf message protos.GetMetricsRequest
 */
export interface GetMetricsRequest {
}
/**
 * @generated from protobuf message protos.GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * @generated from protobuf field: map<string, protos.Metric> metrics = 1;
     */
    metrics: {
        [key: string]: Metric;
    };
    /**
     * Set by server to indicate that the response is a keepalive message
     *
     * @generated from protobuf field: optional bool _keepalive = 1000;
     */
    Keepalive?: boolean; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}
/**
 * Nothing needed here, we return all rates
 *
 * @generated from protobuf message protos.GetAudienceRatesRequest
 */
export interface GetAudienceRatesRequest {
}
/**
 * @generated from protobuf message protos.GetAudienceRatesResponse
 */
export interface GetAudienceRatesResponse {
    /**
     * @generated from protobuf field: map<string, protos.AudienceRate> rates = 1;
     */
    rates: {
        [key: string]: AudienceRate;
    }; // Key is an audience string
    /**
     * Set by server to indicate that the response is a keepalive message
     *
     * @generated from protobuf field: optional bool _keepalive = 1000;
     */
    Keepalive?: boolean; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}
/**
 * @generated from protobuf message protos.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * @generated from protobuf field: protos.Audience audience = 1;
     */
    audience?: Audience;
}
/**
 * @generated from protobuf message protos.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * @generated from protobuf field: protos.Schema schema = 1;
     */
    schema?: Schema;
}
/**
 * @generated from protobuf message protos.AppRegistrationStatusRequest
 */
export interface AppRegistrationStatusRequest {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
}
/**
 * @generated from protobuf message protos.AppRegistrationStatusResponse
 */
export interface AppRegistrationStatusResponse {
    /**
     * @generated from protobuf field: protos.AppRegistrationStatusResponse.Status status = 1;
     */
    status: AppRegistrationStatusResponse_Status;
}
/**
 * @generated from protobuf enum protos.AppRegistrationStatusResponse.Status
 */
export enum AppRegistrationStatusResponse_Status {
    /**
     * @generated from protobuf enum value: STATUS_UNSET = 0;
     */
    UNSET = 0,
    /**
     * Submit means the user is not registered yet
     *
     * @generated from protobuf enum value: STATUS_SUBMIT = 1;
     */
    SUBMIT = 1,
    /**
     * Verify means the user is registered but not verified yet
     *
     * @generated from protobuf enum value: STATUS_VERIFY = 2;
     */
    VERIFY = 2,
    /**
     * Done means the user is registered and verified
     *
     * @generated from protobuf enum value: STATUS_DONE = 3;
     */
    DONE = 3
}
/**
 * @generated from protobuf message protos.AppRegistrationRequest
 */
export interface AppRegistrationRequest {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * @generated from protobuf field: string cluster_id = 2;
     */
    clusterId: string;
    /**
     * Used for storage on ui-bff backend
     *
     * @generated from protobuf field: string _code = 100;
     */
    Code: string; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}
/**
 * @generated from protobuf message protos.AppVerifyRegistrationRequest
 */
export interface AppVerifyRegistrationRequest {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * @generated from protobuf field: string code = 2;
     */
    code: string;
}
/**
 * @generated from protobuf message protos.AppRegisterRejectRequest
 */
export interface AppRegisterRejectRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
}
/**
 * @generated from protobuf message protos.PauseTailRequest
 */
export interface PauseTailRequest {
    /**
     * @generated from protobuf field: string tail_id = 1;
     */
    tailId: string;
}
/**
 * @generated from protobuf message protos.ResumeTailRequest
 */
export interface ResumeTailRequest {
    /**
     * @generated from protobuf field: string tail_id = 1;
     */
    tailId: string;
}
/**
 * @generated from protobuf message protos.TestRequest
 */
export interface TestRequest {
    /**
     * @generated from protobuf field: string input = 1;
     */
    input: string;
}
/**
 * @generated from protobuf message protos.TestResponse
 */
export interface TestResponse {
    /**
     * @generated from protobuf field: string output = 2;
     */
    output: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetAllRequest$Type extends MessageType<GetAllRequest> {
    constructor() {
        super("protos.GetAllRequest", []);
    }
    create(value?: PartialMessage<GetAllRequest>): GetAllRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllRequest): GetAllRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAllRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetAllRequest
 */
export const GetAllRequest = new GetAllRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllResponse$Type extends MessageType<GetAllResponse> {
    constructor() {
        super("protos.GetAllResponse", [
            { no: 1, name: "live", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LiveInfo },
            { no: 2, name: "audiences", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Audience },
            { no: 3, name: "pipelines", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => PipelineInfo } },
            { no: 4, name: "config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => GetAllResponsePipelines } },
            { no: 100, name: "generated_at_unix_ts_ns_utc", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 1000, name: "_keepalive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllResponse>): GetAllResponse {
        const message = { live: [], audiences: [], pipelines: {}, config: {}, generatedAtUnixTsNsUtc: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllResponse): GetAllResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated protos.LiveInfo live */ 1:
                    message.live.push(LiveInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated protos.Audience audiences */ 2:
                    message.audiences.push(Audience.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, protos.PipelineInfo> pipelines */ 3:
                    this.binaryReadMap3(message.pipelines, reader, options);
                    break;
                case /* map<string, protos.GetAllResponsePipelines> config */ 4:
                    this.binaryReadMap4(message.config, reader, options);
                    break;
                case /* int64 generated_at_unix_ts_ns_utc */ 100:
                    message.generatedAtUnixTsNsUtc = reader.int64().toString();
                    break;
                case /* optional bool _keepalive */ 1000:
                    message.Keepalive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: GetAllResponse["pipelines"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetAllResponse["pipelines"] | undefined, val: GetAllResponse["pipelines"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = PipelineInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protos.GetAllResponse.pipelines");
            }
        }
        map[key ?? ""] = val ?? PipelineInfo.create();
    }
    private binaryReadMap4(map: GetAllResponse["config"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetAllResponse["config"] | undefined, val: GetAllResponse["config"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = GetAllResponsePipelines.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protos.GetAllResponse.config");
            }
        }
        map[key ?? ""] = val ?? GetAllResponsePipelines.create();
    }
    internalBinaryWrite(message: GetAllResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated protos.LiveInfo live = 1; */
        for (let i = 0; i < message.live.length; i++)
            LiveInfo.internalBinaryWrite(message.live[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated protos.Audience audiences = 2; */
        for (let i = 0; i < message.audiences.length; i++)
            Audience.internalBinaryWrite(message.audiences[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, protos.PipelineInfo> pipelines = 3; */
        for (let k of Object.keys(message.pipelines)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PipelineInfo.internalBinaryWrite(message.pipelines[k], writer, options);
            writer.join().join();
        }
        /* map<string, protos.GetAllResponsePipelines> config = 4; */
        for (let k of Object.keys(message.config)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            GetAllResponsePipelines.internalBinaryWrite(message.config[k], writer, options);
            writer.join().join();
        }
        /* int64 generated_at_unix_ts_ns_utc = 100; */
        if (message.generatedAtUnixTsNsUtc !== "0")
            writer.tag(100, WireType.Varint).int64(message.generatedAtUnixTsNsUtc);
        /* optional bool _keepalive = 1000; */
        if (message.Keepalive !== undefined)
            writer.tag(1000, WireType.Varint).bool(message.Keepalive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetAllResponse
 */
export const GetAllResponse = new GetAllResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllResponsePipelines$Type extends MessageType<GetAllResponsePipelines> {
    constructor() {
        super("protos.GetAllResponsePipelines", [
            { no: 1, name: "configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PipelineConfig }
        ]);
    }
    create(value?: PartialMessage<GetAllResponsePipelines>): GetAllResponsePipelines {
        const message = { configs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllResponsePipelines>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllResponsePipelines): GetAllResponsePipelines {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated protos.PipelineConfig configs */ 1:
                    message.configs.push(PipelineConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllResponsePipelines, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated protos.PipelineConfig configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            PipelineConfig.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetAllResponsePipelines
 */
export const GetAllResponsePipelines = new GetAllResponsePipelines$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPipelinesRequest$Type extends MessageType<GetPipelinesRequest> {
    constructor() {
        super("protos.GetPipelinesRequest", []);
    }
    create(value?: PartialMessage<GetPipelinesRequest>): GetPipelinesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPipelinesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPipelinesRequest): GetPipelinesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetPipelinesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetPipelinesRequest
 */
export const GetPipelinesRequest = new GetPipelinesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPipelinesResponse$Type extends MessageType<GetPipelinesResponse> {
    constructor() {
        super("protos.GetPipelinesResponse", [
            { no: 1, name: "pipelines", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Pipeline }
        ]);
    }
    create(value?: PartialMessage<GetPipelinesResponse>): GetPipelinesResponse {
        const message = { pipelines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPipelinesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPipelinesResponse): GetPipelinesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated protos.Pipeline pipelines */ 1:
                    message.pipelines.push(Pipeline.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPipelinesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated protos.Pipeline pipelines = 1; */
        for (let i = 0; i < message.pipelines.length; i++)
            Pipeline.internalBinaryWrite(message.pipelines[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetPipelinesResponse
 */
export const GetPipelinesResponse = new GetPipelinesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPipelineRequest$Type extends MessageType<GetPipelineRequest> {
    constructor() {
        super("protos.GetPipelineRequest", [
            { no: 1, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPipelineRequest>): GetPipelineRequest {
        const message = { pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPipelineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPipelineRequest): GetPipelineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pipeline_id */ 1:
                    message.pipelineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPipelineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pipeline_id = 1; */
        if (message.pipelineId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pipelineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetPipelineRequest
 */
export const GetPipelineRequest = new GetPipelineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPipelineResponse$Type extends MessageType<GetPipelineResponse> {
    constructor() {
        super("protos.GetPipelineResponse", [
            { no: 1, name: "pipeline", kind: "message", T: () => Pipeline }
        ]);
    }
    create(value?: PartialMessage<GetPipelineResponse>): GetPipelineResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPipelineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPipelineResponse): GetPipelineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.Pipeline pipeline */ 1:
                    message.pipeline = Pipeline.internalBinaryRead(reader, reader.uint32(), options, message.pipeline);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPipelineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.Pipeline pipeline = 1; */
        if (message.pipeline)
            Pipeline.internalBinaryWrite(message.pipeline, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetPipelineResponse
 */
export const GetPipelineResponse = new GetPipelineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePipelineRequest$Type extends MessageType<CreatePipelineRequest> {
    constructor() {
        super("protos.CreatePipelineRequest", [
            { no: 1, name: "pipeline", kind: "message", T: () => Pipeline }
        ]);
    }
    create(value?: PartialMessage<CreatePipelineRequest>): CreatePipelineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatePipelineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePipelineRequest): CreatePipelineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.Pipeline pipeline */ 1:
                    message.pipeline = Pipeline.internalBinaryRead(reader, reader.uint32(), options, message.pipeline);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePipelineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.Pipeline pipeline = 1; */
        if (message.pipeline)
            Pipeline.internalBinaryWrite(message.pipeline, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.CreatePipelineRequest
 */
export const CreatePipelineRequest = new CreatePipelineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePipelineResponse$Type extends MessageType<CreatePipelineResponse> {
    constructor() {
        super("protos.CreatePipelineResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePipelineResponse>): CreatePipelineResponse {
        const message = { message: "", pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreatePipelineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePipelineResponse): CreatePipelineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* string pipeline_id */ 2:
                    message.pipelineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePipelineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* string pipeline_id = 2; */
        if (message.pipelineId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pipelineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.CreatePipelineResponse
 */
export const CreatePipelineResponse = new CreatePipelineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePipelineRequest$Type extends MessageType<UpdatePipelineRequest> {
    constructor() {
        super("protos.UpdatePipelineRequest", [
            { no: 1, name: "pipeline", kind: "message", T: () => Pipeline }
        ]);
    }
    create(value?: PartialMessage<UpdatePipelineRequest>): UpdatePipelineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePipelineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePipelineRequest): UpdatePipelineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.Pipeline pipeline */ 1:
                    message.pipeline = Pipeline.internalBinaryRead(reader, reader.uint32(), options, message.pipeline);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePipelineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.Pipeline pipeline = 1; */
        if (message.pipeline)
            Pipeline.internalBinaryWrite(message.pipeline, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.UpdatePipelineRequest
 */
export const UpdatePipelineRequest = new UpdatePipelineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePipelineRequest$Type extends MessageType<DeletePipelineRequest> {
    constructor() {
        super("protos.DeletePipelineRequest", [
            { no: 1, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePipelineRequest>): DeletePipelineRequest {
        const message = { pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePipelineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePipelineRequest): DeletePipelineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pipeline_id */ 1:
                    message.pipelineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePipelineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pipeline_id = 1; */
        if (message.pipelineId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pipelineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.DeletePipelineRequest
 */
export const DeletePipelineRequest = new DeletePipelineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPipelinesRequest$Type extends MessageType<SetPipelinesRequest> {
    constructor() {
        super("protos.SetPipelinesRequest", [
            { no: 1, name: "pipeline_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audience", kind: "message", T: () => Audience }
        ]);
    }
    create(value?: PartialMessage<SetPipelinesRequest>): SetPipelinesRequest {
        const message = { pipelineIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPipelinesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPipelinesRequest): SetPipelinesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string pipeline_ids */ 1:
                    message.pipelineIds.push(reader.string());
                    break;
                case /* protos.Audience audience */ 2:
                    message.audience = Audience.internalBinaryRead(reader, reader.uint32(), options, message.audience);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPipelinesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string pipeline_ids = 1; */
        for (let i = 0; i < message.pipelineIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.pipelineIds[i]);
        /* protos.Audience audience = 2; */
        if (message.audience)
            Audience.internalBinaryWrite(message.audience, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.SetPipelinesRequest
 */
export const SetPipelinesRequest = new SetPipelinesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PausePipelineRequest$Type extends MessageType<PausePipelineRequest> {
    constructor() {
        super("protos.PausePipelineRequest", [
            { no: 1, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audience", kind: "message", T: () => Audience }
        ]);
    }
    create(value?: PartialMessage<PausePipelineRequest>): PausePipelineRequest {
        const message = { pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PausePipelineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PausePipelineRequest): PausePipelineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pipeline_id */ 1:
                    message.pipelineId = reader.string();
                    break;
                case /* protos.Audience audience */ 2:
                    message.audience = Audience.internalBinaryRead(reader, reader.uint32(), options, message.audience);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PausePipelineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pipeline_id = 1; */
        if (message.pipelineId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pipelineId);
        /* protos.Audience audience = 2; */
        if (message.audience)
            Audience.internalBinaryWrite(message.audience, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.PausePipelineRequest
 */
export const PausePipelineRequest = new PausePipelineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResumePipelineRequest$Type extends MessageType<ResumePipelineRequest> {
    constructor() {
        super("protos.ResumePipelineRequest", [
            { no: 1, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audience", kind: "message", T: () => Audience }
        ]);
    }
    create(value?: PartialMessage<ResumePipelineRequest>): ResumePipelineRequest {
        const message = { pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResumePipelineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResumePipelineRequest): ResumePipelineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pipeline_id */ 1:
                    message.pipelineId = reader.string();
                    break;
                case /* protos.Audience audience */ 2:
                    message.audience = Audience.internalBinaryRead(reader, reader.uint32(), options, message.audience);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResumePipelineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pipeline_id = 1; */
        if (message.pipelineId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pipelineId);
        /* protos.Audience audience = 2; */
        if (message.audience)
            Audience.internalBinaryWrite(message.audience, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.ResumePipelineRequest
 */
export const ResumePipelineRequest = new ResumePipelineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateNotificationRequest$Type extends MessageType<CreateNotificationRequest> {
    constructor() {
        super("protos.CreateNotificationRequest", [
            { no: 1, name: "notification", kind: "message", T: () => NotificationConfig }
        ]);
    }
    create(value?: PartialMessage<CreateNotificationRequest>): CreateNotificationRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateNotificationRequest): CreateNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.NotificationConfig notification */ 1:
                    message.notification = NotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.notification);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.NotificationConfig notification = 1; */
        if (message.notification)
            NotificationConfig.internalBinaryWrite(message.notification, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.CreateNotificationRequest
 */
export const CreateNotificationRequest = new CreateNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateNotificationRequest$Type extends MessageType<UpdateNotificationRequest> {
    constructor() {
        super("protos.UpdateNotificationRequest", [
            { no: 1, name: "notification", kind: "message", T: () => NotificationConfig }
        ]);
    }
    create(value?: PartialMessage<UpdateNotificationRequest>): UpdateNotificationRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateNotificationRequest): UpdateNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.NotificationConfig notification */ 1:
                    message.notification = NotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.notification);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.NotificationConfig notification = 1; */
        if (message.notification)
            NotificationConfig.internalBinaryWrite(message.notification, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.UpdateNotificationRequest
 */
export const UpdateNotificationRequest = new UpdateNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteNotificationRequest$Type extends MessageType<DeleteNotificationRequest> {
    constructor() {
        super("protos.DeleteNotificationRequest", [
            { no: 1, name: "notification_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteNotificationRequest>): DeleteNotificationRequest {
        const message = { notificationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteNotificationRequest): DeleteNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string notification_id */ 1:
                    message.notificationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string notification_id = 1; */
        if (message.notificationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.notificationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.DeleteNotificationRequest
 */
export const DeleteNotificationRequest = new DeleteNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNotificationsRequest$Type extends MessageType<GetNotificationsRequest> {
    constructor() {
        super("protos.GetNotificationsRequest", []);
    }
    create(value?: PartialMessage<GetNotificationsRequest>): GetNotificationsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetNotificationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNotificationsRequest): GetNotificationsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetNotificationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetNotificationsRequest
 */
export const GetNotificationsRequest = new GetNotificationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNotificationsResponse$Type extends MessageType<GetNotificationsResponse> {
    constructor() {
        super("protos.GetNotificationsResponse", [
            { no: 1, name: "notifications", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => NotificationConfig } }
        ]);
    }
    create(value?: PartialMessage<GetNotificationsResponse>): GetNotificationsResponse {
        const message = { notifications: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetNotificationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNotificationsResponse): GetNotificationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protos.NotificationConfig> notifications */ 1:
                    this.binaryReadMap1(message.notifications, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetNotificationsResponse["notifications"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetNotificationsResponse["notifications"] | undefined, val: GetNotificationsResponse["notifications"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = NotificationConfig.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protos.GetNotificationsResponse.notifications");
            }
        }
        map[key ?? ""] = val ?? NotificationConfig.create();
    }
    internalBinaryWrite(message: GetNotificationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protos.NotificationConfig> notifications = 1; */
        for (let k of Object.keys(message.notifications)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            NotificationConfig.internalBinaryWrite(message.notifications[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetNotificationsResponse
 */
export const GetNotificationsResponse = new GetNotificationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNotificationRequest$Type extends MessageType<GetNotificationRequest> {
    constructor() {
        super("protos.GetNotificationRequest", [
            { no: 1, name: "notification_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetNotificationRequest>): GetNotificationRequest {
        const message = { notificationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNotificationRequest): GetNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string notification_id */ 1:
                    message.notificationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string notification_id = 1; */
        if (message.notificationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.notificationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetNotificationRequest
 */
export const GetNotificationRequest = new GetNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNotificationResponse$Type extends MessageType<GetNotificationResponse> {
    constructor() {
        super("protos.GetNotificationResponse", [
            { no: 1, name: "notification", kind: "message", T: () => NotificationConfig }
        ]);
    }
    create(value?: PartialMessage<GetNotificationResponse>): GetNotificationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetNotificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNotificationResponse): GetNotificationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.NotificationConfig notification */ 1:
                    message.notification = NotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.notification);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNotificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.NotificationConfig notification = 1; */
        if (message.notification)
            NotificationConfig.internalBinaryWrite(message.notification, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetNotificationResponse
 */
export const GetNotificationResponse = new GetNotificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachNotificationRequest$Type extends MessageType<AttachNotificationRequest> {
    constructor() {
        super("protos.AttachNotificationRequest", [
            { no: 1, name: "notification_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttachNotificationRequest>): AttachNotificationRequest {
        const message = { notificationId: "", pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttachNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachNotificationRequest): AttachNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string notification_id */ 1:
                    message.notificationId = reader.string();
                    break;
                case /* string pipeline_id */ 2:
                    message.pipelineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string notification_id = 1; */
        if (message.notificationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.notificationId);
        /* string pipeline_id = 2; */
        if (message.pipelineId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pipelineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.AttachNotificationRequest
 */
export const AttachNotificationRequest = new AttachNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DetachNotificationRequest$Type extends MessageType<DetachNotificationRequest> {
    constructor() {
        super("protos.DetachNotificationRequest", [
            { no: 1, name: "notification_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pipeline_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DetachNotificationRequest>): DetachNotificationRequest {
        const message = { notificationId: "", pipelineId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DetachNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DetachNotificationRequest): DetachNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string notification_id */ 1:
                    message.notificationId = reader.string();
                    break;
                case /* string pipeline_id */ 2:
                    message.pipelineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DetachNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string notification_id = 1; */
        if (message.notificationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.notificationId);
        /* string pipeline_id = 2; */
        if (message.pipelineId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pipelineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.DetachNotificationRequest
 */
export const DetachNotificationRequest = new DetachNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAudienceRequest$Type extends MessageType<DeleteAudienceRequest> {
    constructor() {
        super("protos.DeleteAudienceRequest", [
            { no: 1, name: "audience", kind: "message", T: () => Audience },
            { no: 2, name: "force", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAudienceRequest>): DeleteAudienceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteAudienceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAudienceRequest): DeleteAudienceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.Audience audience */ 1:
                    message.audience = Audience.internalBinaryRead(reader, reader.uint32(), options, message.audience);
                    break;
                case /* optional bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAudienceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.Audience audience = 1; */
        if (message.audience)
            Audience.internalBinaryWrite(message.audience, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool force = 2; */
        if (message.force !== undefined)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.DeleteAudienceRequest
 */
export const DeleteAudienceRequest = new DeleteAudienceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteServiceRequest$Type extends MessageType<DeleteServiceRequest> {
    constructor() {
        super("protos.DeleteServiceRequest", [
            { no: 1, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "force", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteServiceRequest>): DeleteServiceRequest {
        const message = { serviceName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteServiceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteServiceRequest): DeleteServiceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_name */ 1:
                    message.serviceName = reader.string();
                    break;
                case /* optional bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteServiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_name = 1; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* optional bool force = 2; */
        if (message.force !== undefined)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.DeleteServiceRequest
 */
export const DeleteServiceRequest = new DeleteServiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsRequest$Type extends MessageType<GetMetricsRequest> {
    constructor() {
        super("protos.GetMetricsRequest", []);
    }
    create(value?: PartialMessage<GetMetricsRequest>): GetMetricsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricsRequest): GetMetricsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetMetricsRequest
 */
export const GetMetricsRequest = new GetMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsResponse$Type extends MessageType<GetMetricsResponse> {
    constructor() {
        super("protos.GetMetricsResponse", [
            { no: 1, name: "metrics", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Metric } },
            { no: 1000, name: "_keepalive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetMetricsResponse>): GetMetricsResponse {
        const message = { metrics: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMetricsResponse): GetMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protos.Metric> metrics */ 1:
                    this.binaryReadMap1(message.metrics, reader, options);
                    break;
                case /* optional bool _keepalive */ 1000:
                    message.Keepalive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetMetricsResponse["metrics"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetMetricsResponse["metrics"] | undefined, val: GetMetricsResponse["metrics"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Metric.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protos.GetMetricsResponse.metrics");
            }
        }
        map[key ?? ""] = val ?? Metric.create();
    }
    internalBinaryWrite(message: GetMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protos.Metric> metrics = 1; */
        for (let k of Object.keys(message.metrics)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Metric.internalBinaryWrite(message.metrics[k], writer, options);
            writer.join().join();
        }
        /* optional bool _keepalive = 1000; */
        if (message.Keepalive !== undefined)
            writer.tag(1000, WireType.Varint).bool(message.Keepalive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetMetricsResponse
 */
export const GetMetricsResponse = new GetMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAudienceRatesRequest$Type extends MessageType<GetAudienceRatesRequest> {
    constructor() {
        super("protos.GetAudienceRatesRequest", []);
    }
    create(value?: PartialMessage<GetAudienceRatesRequest>): GetAudienceRatesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAudienceRatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAudienceRatesRequest): GetAudienceRatesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAudienceRatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetAudienceRatesRequest
 */
export const GetAudienceRatesRequest = new GetAudienceRatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAudienceRatesResponse$Type extends MessageType<GetAudienceRatesResponse> {
    constructor() {
        super("protos.GetAudienceRatesResponse", [
            { no: 1, name: "rates", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => AudienceRate } },
            { no: 1000, name: "_keepalive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAudienceRatesResponse>): GetAudienceRatesResponse {
        const message = { rates: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAudienceRatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAudienceRatesResponse): GetAudienceRatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protos.AudienceRate> rates */ 1:
                    this.binaryReadMap1(message.rates, reader, options);
                    break;
                case /* optional bool _keepalive */ 1000:
                    message.Keepalive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetAudienceRatesResponse["rates"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetAudienceRatesResponse["rates"] | undefined, val: GetAudienceRatesResponse["rates"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = AudienceRate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field protos.GetAudienceRatesResponse.rates");
            }
        }
        map[key ?? ""] = val ?? AudienceRate.create();
    }
    internalBinaryWrite(message: GetAudienceRatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protos.AudienceRate> rates = 1; */
        for (let k of Object.keys(message.rates)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AudienceRate.internalBinaryWrite(message.rates[k], writer, options);
            writer.join().join();
        }
        /* optional bool _keepalive = 1000; */
        if (message.Keepalive !== undefined)
            writer.tag(1000, WireType.Varint).bool(message.Keepalive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetAudienceRatesResponse
 */
export const GetAudienceRatesResponse = new GetAudienceRatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("protos.GetSchemaRequest", [
            { no: 1, name: "audience", kind: "message", T: () => Audience }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.Audience audience */ 1:
                    message.audience = Audience.internalBinaryRead(reader, reader.uint32(), options, message.audience);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.Audience audience = 1; */
        if (message.audience)
            Audience.internalBinaryWrite(message.audience, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("protos.GetSchemaResponse", [
            { no: 1, name: "schema", kind: "message", T: () => Schema }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.Schema schema */ 1:
                    message.schema = Schema.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.Schema schema = 1; */
        if (message.schema)
            Schema.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppRegistrationStatusRequest$Type extends MessageType<AppRegistrationStatusRequest> {
    constructor() {
        super("protos.AppRegistrationStatusRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppRegistrationStatusRequest>): AppRegistrationStatusRequest {
        const message = { email: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppRegistrationStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppRegistrationStatusRequest): AppRegistrationStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppRegistrationStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.AppRegistrationStatusRequest
 */
export const AppRegistrationStatusRequest = new AppRegistrationStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppRegistrationStatusResponse$Type extends MessageType<AppRegistrationStatusResponse> {
    constructor() {
        super("protos.AppRegistrationStatusResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["protos.AppRegistrationStatusResponse.Status", AppRegistrationStatusResponse_Status, "STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<AppRegistrationStatusResponse>): AppRegistrationStatusResponse {
        const message = { status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppRegistrationStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppRegistrationStatusResponse): AppRegistrationStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protos.AppRegistrationStatusResponse.Status status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppRegistrationStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protos.AppRegistrationStatusResponse.Status status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.AppRegistrationStatusResponse
 */
export const AppRegistrationStatusResponse = new AppRegistrationStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppRegistrationRequest$Type extends MessageType<AppRegistrationRequest> {
    constructor() {
        super("protos.AppRegistrationRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 100, name: "_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppRegistrationRequest>): AppRegistrationRequest {
        const message = { email: "", clusterId: "", Code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppRegistrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppRegistrationRequest): AppRegistrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string cluster_id */ 2:
                    message.clusterId = reader.string();
                    break;
                case /* string _code */ 100:
                    message.Code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppRegistrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string cluster_id = 2; */
        if (message.clusterId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterId);
        /* string _code = 100; */
        if (message.Code !== "")
            writer.tag(100, WireType.LengthDelimited).string(message.Code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.AppRegistrationRequest
 */
export const AppRegistrationRequest = new AppRegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppVerifyRegistrationRequest$Type extends MessageType<AppVerifyRegistrationRequest> {
    constructor() {
        super("protos.AppVerifyRegistrationRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppVerifyRegistrationRequest>): AppVerifyRegistrationRequest {
        const message = { email: "", code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppVerifyRegistrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppVerifyRegistrationRequest): AppVerifyRegistrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppVerifyRegistrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.AppVerifyRegistrationRequest
 */
export const AppVerifyRegistrationRequest = new AppVerifyRegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppRegisterRejectRequest$Type extends MessageType<AppRegisterRejectRequest> {
    constructor() {
        super("protos.AppRegisterRejectRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppRegisterRejectRequest>): AppRegisterRejectRequest {
        const message = { clusterId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppRegisterRejectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppRegisterRejectRequest): AppRegisterRejectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppRegisterRejectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.AppRegisterRejectRequest
 */
export const AppRegisterRejectRequest = new AppRegisterRejectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PauseTailRequest$Type extends MessageType<PauseTailRequest> {
    constructor() {
        super("protos.PauseTailRequest", [
            { no: 1, name: "tail_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PauseTailRequest>): PauseTailRequest {
        const message = { tailId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PauseTailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PauseTailRequest): PauseTailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tail_id */ 1:
                    message.tailId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PauseTailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tail_id = 1; */
        if (message.tailId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tailId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.PauseTailRequest
 */
export const PauseTailRequest = new PauseTailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResumeTailRequest$Type extends MessageType<ResumeTailRequest> {
    constructor() {
        super("protos.ResumeTailRequest", [
            { no: 1, name: "tail_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResumeTailRequest>): ResumeTailRequest {
        const message = { tailId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResumeTailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResumeTailRequest): ResumeTailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tail_id */ 1:
                    message.tailId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResumeTailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tail_id = 1; */
        if (message.tailId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tailId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.ResumeTailRequest
 */
export const ResumeTailRequest = new ResumeTailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestRequest$Type extends MessageType<TestRequest> {
    constructor() {
        super("protos.TestRequest", [
            { no: 1, name: "input", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestRequest>): TestRequest {
        const message = { input: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestRequest): TestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string input */ 1:
                    message.input = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string input = 1; */
        if (message.input !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.input);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.TestRequest
 */
export const TestRequest = new TestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestResponse$Type extends MessageType<TestResponse> {
    constructor() {
        super("protos.TestResponse", [
            { no: 2, name: "output", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TestResponse>): TestResponse {
        const message = { output: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestResponse): TestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string output */ 2:
                    message.output = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string output = 2; */
        if (message.output !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.output);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protos.TestResponse
 */
export const TestResponse = new TestResponse$Type();
/**
 * @generated ServiceType for protobuf service protos.External
 */
export const External = new ServiceType("protos.External", [
    { name: "GetAll", options: {}, I: GetAllRequest, O: GetAllResponse },
    { name: "GetAllStream", serverStreaming: true, options: {}, I: GetAllRequest, O: GetAllResponse },
    { name: "GetPipelines", options: {}, I: GetPipelinesRequest, O: GetPipelinesResponse },
    { name: "GetPipeline", options: {}, I: GetPipelineRequest, O: GetPipelineResponse },
    { name: "CreatePipeline", options: {}, I: CreatePipelineRequest, O: CreatePipelineResponse },
    { name: "UpdatePipeline", options: {}, I: UpdatePipelineRequest, O: StandardResponse },
    { name: "DeletePipeline", options: {}, I: DeletePipelineRequest, O: StandardResponse },
    { name: "SetPipelines", options: {}, I: SetPipelinesRequest, O: StandardResponse },
    { name: "PausePipeline", options: {}, I: PausePipelineRequest, O: StandardResponse },
    { name: "ResumePipeline", options: {}, I: ResumePipelineRequest, O: StandardResponse },
    { name: "CreateNotification", options: {}, I: CreateNotificationRequest, O: StandardResponse },
    { name: "UpdateNotification", options: {}, I: UpdateNotificationRequest, O: StandardResponse },
    { name: "DeleteNotification", options: {}, I: DeleteNotificationRequest, O: StandardResponse },
    { name: "GetNotifications", options: {}, I: GetNotificationsRequest, O: GetNotificationsResponse },
    { name: "GetNotification", options: {}, I: GetNotificationRequest, O: GetNotificationResponse },
    { name: "AttachNotification", options: {}, I: AttachNotificationRequest, O: StandardResponse },
    { name: "DetachNotification", options: {}, I: DetachNotificationRequest, O: StandardResponse },
    { name: "DeleteAudience", options: {}, I: DeleteAudienceRequest, O: StandardResponse },
    { name: "DeleteService", options: {}, I: DeleteServiceRequest, O: StandardResponse },
    { name: "GetMetrics", serverStreaming: true, options: {}, I: GetMetricsRequest, O: GetMetricsResponse },
    { name: "Tail", serverStreaming: true, options: {}, I: TailRequest, O: TailResponse },
    { name: "PauseTail", options: {}, I: PauseTailRequest, O: StandardResponse },
    { name: "ResumeTail", options: {}, I: ResumeTailRequest, O: StandardResponse },
    { name: "GetAudienceRates", serverStreaming: true, options: {}, I: GetAudienceRatesRequest, O: GetAudienceRatesResponse },
    { name: "GetSchema", options: {}, I: GetSchemaRequest, O: GetSchemaResponse },
    { name: "AppRegistrationStatus", options: {}, I: AppRegistrationStatusRequest, O: AppRegistrationStatusResponse },
    { name: "AppRegister", options: {}, I: AppRegistrationRequest, O: StandardResponse },
    { name: "AppVerifyRegistration", options: {}, I: AppVerifyRegistrationRequest, O: StandardResponse },
    { name: "AppRegisterReject", options: {}, I: AppRegisterRejectRequest, O: StandardResponse },
    { name: "Test", options: {}, I: TestRequest, O: TestResponse }
]);
